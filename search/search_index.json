{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"School of SRE","text":"<p>Site Reliability Engineers (SREs)  sits at the intersection of software engineering and systems engineering. While there are potentially infinite permutations and combinations of how infrastructure and software components can be put together to achieve an objective, focusing on foundational skills allows SREs to work with complex systems and software, regardless of whether these systems are proprietary, 3<sup>rd</sup> party, open systems, run on cloud/on-prem infrastructure, etc. Particularly important is to gain a deep understanding of how these areas of systems and infrastructure relate to each other and interact with each other. The combination of software and systems engineering skills is rare and is generally built over time with exposure to a wide variety of infrastructure, systems, and software. </p> <p>SREs bring in engineering practices to keep the site up. Each distributed system is an agglomeration of many components. SREs validate business requirements, convert them to SLAs for each of the components that constitute the distributed system, monitor and measure adherence to SLAs, re-architect or scale out to mitigate or avoid SLA breaches, add these learnings as feedback to new systems or projects and thereby reduce operational toil. Hence SREs play a vital role right from the day 0 design of the system. </p> <p>In early 2019, we started visiting campuses across India to recruit the best and brightest minds to make sure LinkedIn, and all the services that make up its complex technology stack are always available for everyone. This critical function at LinkedIn falls under the purview of the Site Engineering team and Site Reliability Engineers (SREs) who are Software Engineers, specialized in reliability. </p> <p>As we continued on this journey we started getting a lot of questions from these campuses on what exactly the site reliability engineering role entails? And, how could someone learn the skills and the disciplines involved to become a successful site reliability engineer? Fast forward a few months, and a few of these campus students had joined LinkedIn either as interns or as full-time engineers to become a part of the Site Engineering team; we also had a few lateral hires who joined our organization who were not from a traditional SRE background. That's when a few of us got together and started to think about how we can onboard new graduate engineers to the Site Engineering team.</p> <p>There are very few resources out there guiding someone on the basic skill sets one has to acquire as a beginner SRE. Because of the lack of these resources, we felt that individuals have a tough time getting into open positions in the industry. We created the School Of SRE as a starting point for anyone wanting to build their career as an SRE. In this course, we are focusing on building strong foundational skills. The course is structured in a way to provide more real life examples and how learning each of these topics can play an important role in day to day job responsibilities of an SRE. Currently we are covering the following topics under the School Of SRE:</p> <ul> <li> <p>Level 101</p> <ul> <li>Fundamentals Series<ul> <li>Linux Basics</li> <li>Git</li> <li>Linux Networking</li> </ul> </li> <li>Python and Web</li> <li>Data<ul> <li>Relational databases(MySQL)</li> <li>NoSQL concepts</li> <li>Big Data</li> </ul> </li> <li>Systems Design</li> <li>Metrics and Monitoring</li> <li>Security</li> </ul> </li> <li> <p>Level 102</p> <ul> <li>Linux Intermediate</li> <li>Linux Advanced<ul> <li>Containers and orchestration</li> <li>System Calls and Signals</li> </ul> </li> <li>Networking</li> <li>System Design</li> <li>System troubleshooting and performance improvements </li> <li>Continuous Integration and Continuous Delivery</li> </ul> </li> </ul> <p>We believe continuous learning will help in acquiring deeper knowledge and competencies in order to expand your skill sets, every module has added references that could be a guide for further learning. Our hope is that by going through these modules we should be able to build the essential skills required for a Site Reliability Engineer.</p> <p>At LinkedIn, we are using this curriculum for onboarding our non-traditional hires and new college grads into the SRE role. We had multiple rounds of successful onboarding experiences with new employees and the course helped them be productive in a very short period of time. This motivated us to open source the content for helping other organizations in onboarding new engineers into the role and provide guidance for aspiring individuals to get into the role. We realize that the initial content we created is just a starting point and we hope that the community can help in the journey of refining and expanding the content. Check out the contributing guide to get started.</p>"},{"location":"level101/linux_basics/command_line_basics/","title":"Command Line Basics","text":""},{"location":"level101/linux_basics/command_line_basics/#lab-environment-setup","title":"Lab Environment Setup","text":"<p>One can use an online bash interpreter to run all the commands that are provided as examples in this course. This will also help you in getting a hands-on experience of various linux commands.</p> <p>REPL is one of the popular online bash interpreters for running linux commands. We will be using it for running all the commands mentioned in this course.</p>"},{"location":"level101/linux_basics/command_line_basics/#what-is-a-command","title":"What is a Command","text":"<p>A command is a program that tells the operating system to perform specific work. Programs are stored as files in linux. Therefore, a command is also a file which is stored somewhere on the disk.</p> <p>Commands may also take additional arguments as input from the user. These arguments are called command line arguments. Knowing how to use the commands is important and there are many ways to get help in Linux, especially for commands. Almost every command will have some form of documentation, most commands will have a command-line argument -h or --help that will display a reasonable amount of documentation. But the most popular documentation system in Linux is called man pages - short for manual pages.</p> <p>Using --help to show the documentation for ls command.</p> <p></p>"},{"location":"level101/linux_basics/command_line_basics/#file-system-organization","title":"File System Organization","text":"<p>The linux file system has a hierarchical (or tree-like) structure with its highest level directory called root ( denoted by / ). Directories present inside the root directory stores file related to the system. These directories in turn can either store system files or application files or user related files.</p> <p></p> <p>bin   | The executable program of most commonly used commands reside in bin directory</p> <p>dev   | This directory contains files related to devices on the system  </p> <p>etc   | This directory contains all the system configuration files</p> <p>home  | This directory contains user related files and directories.</p> <p>lib   | This directory contains all the library files</p> <p>mnt   | This directory contains files related to mounted devices on the system</p> <p>proc  | This directory contains files related to the running processes on the system</p> <p>root  | This directory contains root user related files and directories.</p> <p>sbin  | This directory contains programs used for system administration.</p> <p>tmp   | This directory is used to store temporary files on the system</p> <p>usr   |  This directory is used to store application programs on the system</p>"},{"location":"level101/linux_basics/command_line_basics/#commands-for-navigating-the-file-system","title":"Commands for Navigating the File System","text":"<p>There are three basic commands which are used frequently to navigate the file system:</p> <ul> <li> <p>ls</p> </li> <li> <p>pwd</p> </li> <li> <p>cd</p> </li> </ul> <p>We will now try to understand what each command does and how to use these commands. You should also practice the given examples on the online bash shell.</p>"},{"location":"level101/linux_basics/command_line_basics/#pwd-print-working-directory","title":"pwd (print working directory)","text":"<p>At any given moment of time, we will be standing in a certain directory. To get the name of the directory in which we are standing, we can use the pwd command in linux.</p> <p></p> <p>We will now use the cd command to move to a different directory and then print the working directory.</p> <p></p>"},{"location":"level101/linux_basics/command_line_basics/#cd-change-directory","title":"cd (change directory)","text":"<p>The cd command can be used to change the working directory. Using the command, you can move from one directory to another.</p> <p>In the below example, we are initially in the root directory. we have then used the cd command to change the directory.</p> <p></p>"},{"location":"level101/linux_basics/command_line_basics/#ls-list-files-and-directories","title":"ls (list files and directories)**","text":"<p>The ls command is used to list the contents of a directory. It will list down all the files and folders present in the given directory.</p> <p>If we just type ls in the shell, it will list all the files and directories present in the current directory.</p> <p></p> <p>We can also provide the directory name as argument to ls command. It will then list all the files and directories inside the given directory.</p> <p></p>"},{"location":"level101/linux_basics/command_line_basics/#commands-for-manipulating-files","title":"Commands for Manipulating Files","text":"<p>There are five basic commands which are used frequently to manipulate files:</p> <ul> <li> <p>touch</p> </li> <li> <p>mkdir</p> </li> <li> <p>cp</p> </li> <li> <p>mv</p> </li> <li> <p>rm</p> </li> </ul> <p>We will now try to understand what each command does and how to use these commands. You should also practice the given examples on the online bash shell.</p>"},{"location":"level101/linux_basics/command_line_basics/#touch-create-new-file","title":"touch (create new file)","text":"<p>The touch command can be used to create an empty new file. This command is very useful for many other purposes but we will discuss the simplest use case of creating a new file.</p> <p>General syntax of using touch command</p> <pre><code>touch &lt;file_name&gt;\n</code></pre> <p></p>"},{"location":"level101/linux_basics/command_line_basics/#mkdir-create-new-directories","title":"mkdir (create new directories)","text":"<p>The mkdir command is used to create directories.You can use ls command to verify that the new directory is created.</p> <p>General syntax of using mkdir command</p> <pre><code>mkdir &lt;directory_name&gt;\n</code></pre> <p></p>"},{"location":"level101/linux_basics/command_line_basics/#rm-delete-files-and-directories","title":"rm (delete files and directories)","text":"<p>The rm command can be used to delete files and directories. It is very important to note that this command permanently deletes the files and directories. It's almost impossible to recover these files and directories once you have executed rm command on them successfully. Do run this command with care.</p> <p>General syntax of using rm command:</p> <pre><code>rm &lt;file_name&gt;\n</code></pre> <p>Let's try to understand the rm command with an example. We will try to delete the file and directory we created using touch and mkdir command respectively.</p> <p></p>"},{"location":"level101/linux_basics/command_line_basics/#cp-copy-files-and-directories","title":"cp (copy files and directories)","text":"<p>The cp command is used to copy files and directories from one location to another. Do note that the cp command doesn't do any change to the original files or directories. The original files or directories and their copy both co-exist after running cp command successfully.</p> <p>General syntax of using cp command:</p> <pre><code>cp &lt;source_path&gt; &lt;destination_path&gt;\n</code></pre> <p>We are currently in the '/home/runner' directory. We will use the mkdir command to create a new directory named \"test_directory\". We will now try to copy the \"_test_runner.py\" file to the directory we created just now.</p> <p></p> <p>Do note that nothing happened to the original \"_test_runner.py\" file. It's still there in the current directory. A new copy of it got created inside the \"test_directory\".</p> <p></p> <p>We can also use the cp command to copy the whole directory from one location to another. Let's try to understand this with an example.</p> <p></p> <p>We again used the mkdir command to create a new directory called \"another_directory\". We then used the cp command along with an additional argument '-r' to copy the \"test_directory\".</p> <p>mv (move files and directories)</p> <p>The mv command can either be used to move files or directories from one location to another or it can be used to rename files or directories. Do note that moving files and copying them are very different. When you move the files or directories, the original copy is lost.</p> <p>General syntax of using mv command:</p> <pre><code>mv &lt;source_path&gt; &lt;destination_path&gt;\n</code></pre> <p>In this example, we will use the mv command to move the \"_test_runner.py\" file to \"test_directory\". In this case, this file already exists in \"test_directory\". The mv command will just replace it. Do note that the original file doesn't exist in the current directory after mv command ran successfully.</p> <p></p> <p>We can also use the mv command to move a directory from one location to another. In this case, we do not need to use the '-r' flag that we did while using the cp command. Do note that the original directory will not exist if we use mv command.</p> <p>One of the important uses of the mv command is to rename files and directories. Let's see how we can use this command for renaming.</p> <p>We have first changed our location to \"test_directory\". We then use the mv command to rename the \"\"_test_runner.py\" file to \"test.py\".</p> <p></p>"},{"location":"level101/linux_basics/command_line_basics/#commands-for-viewing-files","title":"Commands for Viewing Files","text":"<p>There are five basic commands which are used frequently to view the files:</p> <ul> <li> <p>cat</p> </li> <li> <p>head</p> </li> <li> <p>tail</p> </li> <li> <p>more</p> </li> <li> <p>less</p> </li> </ul> <p>We will now try to understand what each command does and how to use these commands. You should also practice the given examples on the online bash shell.</p> <p>We will create a new file called \"numbers.txt\" and insert numbers from 1 to 100 in this file. Each number will be in a separate line.</p> <p></p> <p>Do not worry about the above command now. It's an advanced command which is used to generate numbers. We have then used a redirection operator to push these numbers to the file. We will be discussing I/O redirection in the later sections.</p>"},{"location":"level101/linux_basics/command_line_basics/#cat","title":"cat","text":"<p>The most simplest use of cat command is to print the contents of the file on your output screen. This command is very useful and can be used for many other purposes. We will study about other use cases later.</p> <p></p> <p>You can try to run the above command and you will see numbers being printed from 1 to 100 on your screen. You will need to scroll up to view all the numbers.</p>"},{"location":"level101/linux_basics/command_line_basics/#head","title":"head","text":"<p>The head command displays the first 10 lines of the file by default. We can include additional arguments to display as many lines as we want from the top.</p> <p>In this example, we are only able to see the first 10 lines from the file when we use the head command.</p> <p></p> <p>By default, head command will only display the first 10 lines. If we want to specify the number of lines we want to see from start, use the '-n' argument to provide the input.</p> <p></p>"},{"location":"level101/linux_basics/command_line_basics/#tail","title":"tail","text":"<p>The tail command displays the last 10 lines of the file by default. We can include additional arguments to display as many lines as we want from the end of the file.</p> <p></p> <p>By default, the tail command will only display the last 10 lines. If we want to specify the number of lines we want to see from the end, use '-n' argument to provide the input.</p> <p></p> <p>In this example, we are only able to see the last 5 lines from the file when we use the tail command with explicit -n option.</p>"},{"location":"level101/linux_basics/command_line_basics/#more","title":"more","text":"<p>More command displays the contents of a file or a command output,  displaying one screen at a time in case the file is large (Eg: log files). It also allows forward navigation and limited backward navigation in the file.</p> <p></p> <p>More command displays as much as can fit on the current screen and waits for user input to advance. Forward navigation can be done by pressing Enter, which advances the output by one line and Space, which advances the output by one screen.</p>"},{"location":"level101/linux_basics/command_line_basics/#less","title":"less","text":"<p>Less command is an improved version of more. It displays the contents of a file or a command output, one page at a time. It allows backward navigation as well as forward navigation in the file and also has search options. We can use arrow keys for advancing backward or forward by one line. For moving forward by one page, press Space and for moving backward by one page, press b on your keyboard. You can go to the beginning and the end of a file instantly.</p>"},{"location":"level101/linux_basics/command_line_basics/#echo-command-in-linux","title":"Echo Command in Linux","text":"<p>The echo command is one of the simplest commands that is used in the shell. This command is equivalent to what we have  in other programming languages. <p>The echo command prints the given input string on the screen.</p> <p></p>"},{"location":"level101/linux_basics/command_line_basics/#text-processing-commands","title":"Text Processing Commands","text":"<p>In the previous section, we learned how to view the content of a file. In many cases, we will be interested in performing the below operations:</p> <ul> <li> <p>Print only the lines which contain a particular word(s)</p> </li> <li> <p>Replace a particular word with another word in a file</p> </li> <li> <p>Sort the lines in a particular order</p> </li> </ul> <p>There are three basic commands which are used frequently to process texts:</p> <ul> <li> <p>grep</p> </li> <li> <p>sed</p> </li> <li> <p>sort</p> </li> </ul> <p>We will now try to understand what each command does and how to use these commands. You should also practice the given examples on the online bash shell.</p> <p>We will create a new file called \"numbers.txt\" and insert numbers from 1 to 10 in this file. Each number will be in a separate line.</p> <p></p>"},{"location":"level101/linux_basics/command_line_basics/#grep","title":"grep","text":"<p>The grep command in its simplest form can be used to search particular words in a text file. It will display all the lines in a file that contains a particular input. The word we want to search is provided as an input to the grep command.</p> <p>General syntax of using grep command:</p> <pre><code>grep &lt;word_to_search&gt; &lt;file_name&gt;\n</code></pre> <p>In this example, we are trying to search for a string \"1\" in this file. The grep command outputs the lines where it found this string.</p> <p></p>"},{"location":"level101/linux_basics/command_line_basics/#sed","title":"sed","text":"<p>The sed command in its simplest form can be used to replace a text in a file.</p> <p>General syntax of using the sed command for replacement:</p> <pre><code>sed 's/&lt;text_to_replace&gt;/&lt;replacement_text&gt;/' &lt;file_name&gt;\n</code></pre> <p>Let's try to replace each occurrence of \"1\" in the file with \"3\" using sed command.</p> <p></p> <p>The content of the file will not change in the above example. To do so, we have to use an extra argument '-i' so that the changes are reflected back in the file.</p>"},{"location":"level101/linux_basics/command_line_basics/#sort","title":"sort","text":"<p>The sort command can be used to sort the input provided to it as an argument. By default, it will sort in increasing order.</p> <p>Let's first see the content of the file before trying to sort it.</p> <p></p> <p>Now, we will try to sort the file using the sort command. The sort command sorts the content in lexicographical order.</p> <p></p> <p>The content of the file will not change in the above example.</p>"},{"location":"level101/linux_basics/command_line_basics/#io-redirection","title":"I/O Redirection","text":"<p>Each open file gets assigned a file descriptor. A file descriptor is an unique identifier for open files in the system. There are always three default files open, stdin (the keyboard), stdout (the screen), and stderr (error messages output to the screen). These files can be redirected.</p> <p>Everything is a file in linux - https://unix.stackexchange.com/questions/225537/everything-is-a-file</p> <p>Till now, we have displayed all the output on the screen which is the standard output. We can use some special operators to redirect the output of the command to files or even to the input of other commands. I/O redirection is a very powerful feature.</p> <p>In the below example, we have used the '&gt;' operator to redirect the output of ls command to output.txt file.</p> <p></p> <p>In the below example, we have redirected the output from echo command to a file.</p> <p></p> <p>We can also redirect the output of a command as an input to another command. This is possible with the help of pipes.</p> <p>In the below example, we have passed the output of cat command as an input to grep command using pipe(|) operator.</p> <p></p> <p>In the below example, we have passed the output of sort command as an input to uniq command using pipe(|) operator. The uniq command only prints the unique numbers from the input.</p> <p></p> <p>I/O redirection - https://tldp.org/LDP/abs/html/io-redirection.html</p>"},{"location":"level101/linux_basics/intro/","title":"Linux Basics","text":""},{"location":"level101/linux_basics/intro/#introduction","title":"Introduction","text":""},{"location":"level101/linux_basics/intro/#prerequisites","title":"Prerequisites","text":"<ul> <li>Should be comfortable in using any operating systems like Windows, Linux or Mac</li> <li>Expected to have fundamental knowledge of operating systems</li> </ul>"},{"location":"level101/linux_basics/intro/#what-to-expect-from-this-course","title":"What to expect from this course","text":"<p>This course is divided into three parts. In the first part, we cover the fundamentals of Linux operating systems. We will talk about Linux architecture, Linux distributions and uses of Linux operating systems. We will also talk about the difference between GUI and CLI.</p> <p>In the second part, we cover some basic commands used in Linux.  We will focus on commands used for navigating the file system, viewing and manipulating files, I/O redirection etc.</p> <p>In the third part, we cover Linux system administration. This includes day to day tasks  performed by Linux admins, like managing users/groups, managing file permissions,  monitoring system performance, log files etc.</p> <p>In the second and third part, we will be taking examples to understand the concepts.</p>"},{"location":"level101/linux_basics/intro/#what-is-not-covered-under-this-course","title":"What is not covered under this course","text":"<p>We are not covering advanced Linux commands and bash scripting in this course. We will also not be covering Linux internals. </p>"},{"location":"level101/linux_basics/intro/#course-contents","title":"Course Contents","text":"<p>The following topics has been covered in this course:</p> <ul> <li>Introduction to Linux<ul> <li>What are Linux Operating Systems</li> <li>What are popular Linux distributions</li> <li>Uses of Linux Operating Systems</li> <li>Linux Architecture</li> <li>Graphical user interface (GUI) vs Command line interface (CLI)</li> </ul> </li> <li>Command Line Basics<ul> <li>Lab Environment Setup</li> <li>What is a Command</li> <li>File System Organization</li> <li>Navigating File System</li> <li>Manipulating Files</li> <li>Viewing Files</li> <li>Echo Command</li> <li>Text Processing Commands</li> <li>I/O Redirection</li> </ul> </li> <li>Linux system administration<ul> <li>Lab Environment Setup</li> <li>User/Groups management</li> <li>Becoming a Superuser</li> <li>File Permissions</li> <li>SSH Command</li> <li>Package Management</li> <li>Process Management</li> <li>Memory Management</li> <li>Daemons and Systemd</li> <li>Logs</li> </ul> </li> <li>Conclusion<ul> <li>Applications in SRE Role</li> <li>Useful Courses and tutorials</li> </ul> </li> </ul>"},{"location":"level101/linux_basics/intro/#what-are-linux-operating-systems","title":"What are Linux operating systems","text":"<p>Most of us are familiar with the Windows operating system used in more than  75% of the personal computers. The Windows operating systems are based on Windows NT kernel. </p> <p>A kernel is the most important part of an operating system - it performs important functions like process management, memory management, filesystem management etc.</p> <p>Linux operating systems are based on the Linux kernel. A Linux based operating system will consist of Linux kernel, GUI/CLI, system libraries and system utilities. The Linux kernel was independently developed and released by Linus Torvalds. The Linux kernel is free and open-source - https://github.com/torvalds/linux</p> <p>Linux is a kernel and not a complete operating system. Linux kernel is combined with GNU system to make a complete operating system. Therefore, linux based operating systems are also called as GNU/Linux systems. GNU is an extensive collection of free softwares like compiler, debugger, C library etc. Linux and the GNU  System</p> <p>History of Linux - https://en.wikipedia.org/wiki/History_of_Linux</p>"},{"location":"level101/linux_basics/intro/#what-are-popular-linux-distributions","title":"What are popular Linux distributions","text":"<p>A Linux distribution(distro) is an operating system based on the Linux kernel and a package management system. A package management system consists of tools that help in installing, upgrading, configuring and removing softwares on the operating system.</p> <p>Software are usually adopted to a distribution and are packaged in a distro specific format. These packages are available through a distro specific repository. Packages are installed and managed in the operating system by a package manager.</p> <p>List of popular Linux distributions:</p> <ul> <li> <p>Fedora</p> </li> <li> <p>Ubuntu</p> </li> <li> <p>Debian</p> </li> <li> <p>Centos</p> </li> <li> <p>Red Hat Enterprise Linux</p> </li> <li> <p>Suse</p> </li> <li> <p>Arch Linux</p> </li> </ul> Packaging systems Distributions Package manager Debian style (.deb) Debian, Ubuntu APT Red Hat style (.rpm) Fedora, CentOS, Red Hat Enterprise Linux YUM"},{"location":"level101/linux_basics/intro/#linux-architecture","title":"Linux Architecture","text":"<ul> <li> <p>The Linux kernel is monolithic in nature.</p> </li> <li> <p>System calls are used to interact with the Linux kernel space.</p> </li> <li> <p>Kernel code can only be executed in the kernel mode. Non-kernel code is executed in the user mode.</p> </li> <li> <p>Device drivers are used to communicate with the hardware devices.</p> </li> </ul>"},{"location":"level101/linux_basics/intro/#uses-of-linux-operating-systems","title":"Uses of Linux Operating Systems","text":"<p>Operating system based on Linux kernel are widely used in:</p> <ul> <li> <p>Personal computers</p> </li> <li> <p>Servers</p> </li> <li> <p>Mobile phones - Android is based on Linux operating system</p> </li> <li> <p>Embedded devices - watches, televisions, traffic lights etc</p> </li> <li> <p>Satellites</p> </li> <li> <p>Network devices - routers, switches etc.</p> </li> </ul>"},{"location":"level101/linux_basics/intro/#graphical-user-interface-gui-vs-command-line-interface-cli","title":"Graphical user interface (GUI) vs Command line interface (CLI)","text":"<p>A user interacts with a computer with the help of user interfaces. The user interface can be either GUI or CLI.</p> <p>Graphical user interface allows a user to interact with the computer using graphics such as icons and images. When a user clicks on an icon to open an application on a computer, he or she is actually using the GUI. It's easy to perform tasks using GUI.</p> <p>Command line interface allows a user to interact with the computer using commands. A user types the command in a terminal and the system helps in executing these commands. A new user with experience on GUI may find it  difficult to interact with CLI as he/she needs to be aware of the commands to perform a particular operation.</p>"},{"location":"level101/linux_basics/intro/#shell-vs-terminal","title":"Shell vs Terminal","text":"<p>Shell is a program that takes commands from the users and gives them to the operating system for processing. Shell is an example of a CLI (command line interface). Bash is one of the most popular shell programs available on Linux servers. Other popular shell programs are zsh, ksh and tcsh.</p> <p>Terminal is a program that opens a window and lets you interact with the shell. Some popular examples of terminals are gnome-terminal, xterm, konsole etc.</p> <p>Linux users do use the terms shell, terminal, prompt, console etc. interchangeably. In simple terms, these all refer to a way of taking commands from the user.</p>"},{"location":"level101/linux_networking/http/","title":"HTTP","text":"<p>Till this point we have only got the IP address of linkedin.com. The HTML page of linkedin.com is served by HTTP protocol which the browser renders. Browser sends a HTTP request to the IP of the server determined above. Request has a verb GET, PUT, POST followed by a path and query parameters and lines of key value pair which gives information about the client and capabilities of the client like contents it can accept and a body (usually in POST or PUT)</p> <p><pre><code># Eg run the following in your container and have a look at the headers \ncurl linkedin.com -v\n</code></pre> <pre><code>* Connected to linkedin.com (108.174.10.10) port 80 (#0)\n&gt; GET / HTTP/1.1\n&gt; Host: linkedin.com\n&gt; User-Agent: curl/7.64.1\n&gt; Accept: */*\n&gt; \n&lt; HTTP/1.1 301 Moved Permanently\n&lt; Date: Mon, 09 Nov 2020 10:39:43 GMT\n&lt; X-Li-Pop: prod-esv5\n&lt; X-LI-Proto: http/1.1\n&lt; Location: https://www.linkedin.com/\n&lt; Content-Length: 0\n&lt; \n* Connection #0 to host linkedin.com left intact\n* Closing connection 0\n</code></pre></p> <p>Here, in the first line GET is the verb, / is the path and 1.1 is the HTTP protocol version. Then there are key value pairs which give client capabilities and some details to the server. The server responds back with HTTP version, Status Code and Status message. Status codes 2xx means success, 3xx denotes redirection, 4xx denotes client side errors and 5xx server side errors.</p> <p>We will now jump in to see the difference between HTTP/1.0 and HTTP/1.1. </p> <pre><code>#On the terminal type\ntelnet  www.linkedin.com 80\n#Copy and paste the following with an empty new line at last in the telnet STDIN\nGET / HTTP/1.1\nHOST:linkedin.com\nUSER-AGENT: curl\n</code></pre> <p>This would get server response and waits for next input as the underlying connection to www.linkedin.com can be reused for further queries. While going through TCP, we can understand the benefits of this. But in HTTP/1.0 this connection will be immediately closed after the response meaning new connection has to be opened for each query. HTTP/1.1 can have only one inflight request in an open connection but connection can be reused for multiple requests one after another. One of the benefits of HTTP/2.0 over HTTP/1.1 is we can have multiple inflight requests on the same connection. We are restricting our scope to generic HTTP and not jumping to the intricacies of each protocol version but they should be straight forward to understand post the course.</p> <p>HTTP is  called stateless protocol. This section we will try to understand what stateless means. Say we logged in to linkedin.com, each request to linkedin.com from the client will have no context of the user and it makes no sense to prompt user to login for each page/resource. This problem of HTTP is solved by COOKIE. A user is created a session when a user logs in. This session identifier is sent to the browser via SET-COOKIE header. The browser stores the COOKIE till the expiry set by the server and sends the cookie for each request from hereon for linkedin.com. More details on cookies are available here. Cookies are a critical piece of information like password and since HTTP is a plain text protocol, any man in the middle can capture either password or cookies and can breach the privacy of the user. Similarly as discussed during DNS a spoofed IP of linkedin.com can cause a phishing attack on users where an user can give linkedin\u2019s password to login on the malicious site. To solve both problems HTTPs came in place and HTTPs has to be mandated.</p> <p>HTTPS has to provide server identification and encryption of data between client and server. The server administrator has to generate a private public key pair and certificate request. This certificate request has to be signed by a certificate authority which converts the certificate request to a certificate. The server administrator has to update the certificate and private key to the webserver. The certificate has details about the server (like domain name for which it serves, expiry date), public key of the server. The private key is a secret to the server and losing the private key loses the trust the server provides. When clients connect, the client sends a HELLO. The server sends its certificate to the client. The client checks the validity of the cert by seeing if it is within its expiry time, if it is signed by a trusted authority and the hostname in the cert is the same as the server. This validation makes sure the server is the right server and there is no phishing. Once that is validated, the client negotiates a symmetrical key and cipher with the server by encrypting the negotiation with the public key of the server. Nobody else other than the server who has the private key can understand this data. Once negotiation is complete, that symmetric key and algorithm is used for further encryption which can be decrypted only by client and server from thereon as they only know the symmetric key and algorithm. The switch to symmetric algorithm from asymmetric encryption algorithm is to not strain the resources of client devices as symmetric encryption is generally less resource intensive than asymmetric. </p> <p><pre><code>#Try the following on your terminal to see the cert details like Subject Name(domain name), Issuer details, Expiry date\ncurl https://www.linkedin.com -v \n</code></pre> <pre><code>* Connected to www.linkedin.com (13.107.42.14) port 443 (#0)\n* ALPN, offering h2\n* ALPN, offering http/1.1\n* successfully set certificate verify locations:\n*   CAfile: /etc/ssl/cert.pem\n  CApath: none\n* TLSv1.2 (OUT), TLS handshake, Client hello (1):\n} [230 bytes data]\n* TLSv1.2 (IN), TLS handshake, Server hello (2):\n{ [90 bytes data]\n* TLSv1.2 (IN), TLS handshake, Certificate (11):\n{ [3171 bytes data]\n* TLSv1.2 (IN), TLS handshake, Server key exchange (12):\n{ [365 bytes data]\n* TLSv1.2 (IN), TLS handshake, Server finished (14):\n{ [4 bytes data]\n* TLSv1.2 (OUT), TLS handshake, Client key exchange (16):\n} [102 bytes data]\n* TLSv1.2 (OUT), TLS change cipher, Change cipher spec (1):\n} [1 bytes data]\n* TLSv1.2 (OUT), TLS handshake, Finished (20):\n} [16 bytes data]\n* TLSv1.2 (IN), TLS change cipher, Change cipher spec (1):\n{ [1 bytes data]\n* TLSv1.2 (IN), TLS handshake, Finished (20):\n{ [16 bytes data]\n* SSL connection using TLSv1.2 / ECDHE-RSA-AES256-GCM-SHA384\n* ALPN, server accepted to use h2\n* Server certificate:\n*  subject: C=US; ST=California; L=Sunnyvale; O=LinkedIn Corporation; CN=www.linkedin.com\n*  start date: Oct  2 00:00:00 2020 GMT\n*  expire date: Apr  2 12:00:00 2021 GMT\n*  subjectAltName: host \"www.linkedin.com\" matched cert's \"www.linkedin.com\"\n*  issuer: C=US; O=DigiCert Inc; CN=DigiCert SHA2 Secure Server CA\n*  SSL certificate verify ok.\n* Using HTTP2, server supports multi-use\n* Connection state changed (HTTP/2 confirmed)\n* Copying HTTP/2 data in stream buffer to connection buffer after upgrade: len=0\n* Using Stream ID: 1 (easy handle 0x7fb055808200)\n* Connection state changed (MAX_CONCURRENT_STREAMS == 100)!\n  0 82117    0     0    0     0      0      0 --:--:-- --:--:-- --:--:--     0\n* Connection #0 to host www.linkedin.com left intact\nHTTP/2 200 \ncache-control: no-cache, no-store\npragma: no-cache\ncontent-length: 82117\ncontent-type: text/html; charset=utf-8\nexpires: Thu, 01 Jan 1970 00:00:00 GMT\nset-cookie: JSESSIONID=ajax:2747059799136291014; SameSite=None; Path=/; Domain=.www.linkedin.com; Secure\nset-cookie: lang=v=2&amp;lang=en-us; SameSite=None; Path=/; Domain=linkedin.com; Secure\nset-cookie: bcookie=\"v=2&amp;70bd59e3-5a51-406c-8e0d-dd70befa8890\"; domain=.linkedin.com; Path=/; Secure; Expires=Wed, 09-Nov-2022 22:27:42 GMT; SameSite=None\nset-cookie: bscookie=\"v=1&amp;202011091050107ae9b7ac-fe97-40fc-830d-d7a9ccf80659AQGib5iXwarbY8CCBP94Q39THkgUlx6J\"; domain=.www.linkedin.com; Path=/; Secure; Expires=Wed, 09-Nov-2022 22:27:42 GMT; HttpOnly; SameSite=None\nset-cookie: lissc=1; domain=.linkedin.com; Path=/; Secure; Expires=Tue, 09-Nov-2021 10:50:10 GMT; SameSite=None\nset-cookie: lidc=\"b=VGST04:s=V:r=V:g=2201:u=1:i=1604919010:t=1605005410:v=1:sig=AQHe-KzU8i_5Iy6MwnFEsgRct3c9Lh5R\"; Expires=Tue, 10 Nov 2020 10:50:10 GMT; domain=.linkedin.com; Path=/; SameSite=None; Secure\nx-fs-txn-id: 2b8d5409ba70\nx-fs-uuid: 61bbf94956d14516302567fc882b0000\nexpect-ct: max-age=86400, report-uri=\"https://www.linkedin.com/platform-telemetry/ct\"\nx-xss-protection: 1; mode=block\ncontent-security-policy-report-only: default-src 'none'; connect-src 'self' www.linkedin.com www.google-analytics.com https://dpm.demdex.net/id lnkd.demdex.net blob: https://linkedin.sc.omtrdc.net/b/ss/ static.licdn.com static-exp1.licdn.com static-exp2.licdn.com static-exp3.licdn.com; script-src 'sha256-THuVhwbXPeTR0HszASqMOnIyxqEgvGyBwSPBKBF/iMc=' 'sha256-PyCXNcEkzRWqbiNr087fizmiBBrq9O6GGD8eV3P09Ik=' 'sha256-2SQ55Erm3CPCb+k03EpNxU9bdV3XL9TnVTriDs7INZ4=' 'sha256-S/KSPe186K/1B0JEjbIXcCdpB97krdzX05S+dHnQjUs=' platform.linkedin.com platform-akam.linkedin.com platform-ecst.linkedin.com platform-azur.linkedin.com static.licdn.com static-exp1.licdn.com static-exp2.licdn.com static-exp3.licdn.com; img-src data: blob: *; font-src data: *; style-src 'self' 'unsafe-inline' static.licdn.com static-exp1.licdn.com static-exp2.licdn.com static-exp3.licdn.com; media-src dms.licdn.com; child-src blob: *; frame-src 'self' lnkd.demdex.net linkedin.cdn.qualaroo.com; manifest-src 'self'; report-uri https://www.linkedin.com/platform-telemetry/csp?f=g\ncontent-security-policy: default-src *; connect-src 'self' https://media-src.linkedin.com/media/ www.linkedin.com s.c.lnkd.licdn.com m.c.lnkd.licdn.com s.c.exp1.licdn.com s.c.exp2.licdn.com m.c.exp1.licdn.com m.c.exp2.licdn.com wss://*.linkedin.com dms.licdn.com https://dpm.demdex.net/id lnkd.demdex.net blob: https://accounts.google.com/gsi/status https://linkedin.sc.omtrdc.net/b/ss/ www.google-analytics.com static.licdn.com static-exp1.licdn.com static-exp2.licdn.com static-exp3.licdn.com media.licdn.com media-exp1.licdn.com media-exp2.licdn.com media-exp3.licdn.com; img-src data: blob: *; font-src data: *; style-src 'unsafe-inline' 'self' static-src.linkedin.com *.licdn.com; script-src 'report-sample' 'unsafe-inline' 'unsafe-eval' 'self' spdy.linkedin.com static-src.linkedin.com *.ads.linkedin.com *.licdn.com static.chartbeat.com www.google-analytics.com ssl.google-analytics.com bcvipva02.rightnowtech.com www.bizographics.com sjs.bizographics.com js.bizographics.com d.la4-c1-was.salesforceliveagent.com slideshare.www.linkedin.com https://snap.licdn.com/li.lms-analytics/ platform.linkedin.com platform-akam.linkedin.com platform-ecst.linkedin.com platform-azur.linkedin.com; object-src 'none'; media-src blob: *; child-src blob: lnkd-communities: voyager: *; frame-ancestors 'self'; report-uri https://www.linkedin.com/platform-telemetry/csp?f=l\nx-frame-options: sameorigin\nx-content-type-options: nosniff\nstrict-transport-security: max-age=2592000\nx-li-fabric: prod-lva1\nx-li-pop: afd-prod-lva1\nx-li-proto: http/2\nx-li-uuid: Ybv5SVbRRRYwJWf8iCsAAA==\nx-msedge-ref: Ref A: CFB9AC1D2B0645DDB161CEE4A4909AEF Ref B: BOM02EDGE0712 Ref C: 2020-11-09T10:50:10Z\ndate: Mon, 09 Nov 2020 10:50:10 GMT\n\n* Closing connection 0\n</code></pre></p> <p>Here my system has a list of certificate authorities it trusts in this file  /etc/ssl/cert.pem. Curl validates the certificate is for www.linkedin.com by seeing the CN section of the subject part of the certificate. It also makes sure the certificate is not expired by seeing the expire date. It also validates the signature on the certificate by using the public key of issuer Digicert in  /etc/ssl/cert.pem. Once this is done, using the public key of www.linkedin.com it negotiates cipher TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384 with a symmetric key. Subsequent data transfer including first HTTP request uses the same cipher and symmetric key.</p>"},{"location":"level101/linux_networking/intro/","title":"Linux Networking Fundamentals","text":""},{"location":"level101/linux_networking/intro/#prerequisites","title":"Prerequisites","text":"<ul> <li>High-level knowledge of commonly used jargon in TCP/IP stack like  DNS, TCP, UDP and HTTP</li> <li>Linux Commandline Basics</li> </ul>"},{"location":"level101/linux_networking/intro/#what-to-expect-from-this-course","title":"What to expect from this course","text":"<p>Throughout the course, we cover how an SRE can optimize the system to improve their web stack performance and troubleshoot if there is an issue in any of the layers of the networking stack. This course tries to dig through each layer of traditional TCP/IP stack and expects an SRE to have a picture beyond the bird\u2019s eye view of the functioning of the Internet.</p>"},{"location":"level101/linux_networking/intro/#what-is-not-covered-under-this-course","title":"What is not covered under this course","text":"<p>This course spends time on the fundamentals. We are not covering concepts like HTTP/2.0, QUIC, TCP congestion control protocols, Anycast, BGP, CDN, Tunnels and Multicast. We expect that this course will provide the relevant basics to understand such concepts</p>"},{"location":"level101/linux_networking/intro/#birds-eye-view-of-the-course","title":"Birds eye view of the course","text":"<p>The course covers the question \u201cWhat happens when you open linkedin.com in your browser?\u201d The course follows the flow of TCP/IP stack.More specifically, the course covers topics of Application layer protocols DNS and HTTP, transport layer protocols UDP and TCP, networking layer protocol IP and Data Link Layer protocol </p>"},{"location":"level101/linux_networking/intro/#course-contents","title":"Course Contents","text":"<ol> <li>DNS</li> <li>UDP</li> <li>HTTP</li> <li>TCP</li> <li>IP Routing</li> </ol>"}]}